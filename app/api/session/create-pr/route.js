/**
 * app/api/session/create-pr/route.js
 *
 * Opens a single pull request on GitHub for all the fixes committed
 * to the session branch. The PR body lists every fix with the page URL,
 * file changed, and what was fixed.
 *
 * After the PR is created we update the session status to 'pr_created'
 * and store the PR URL so the user can always find it.
 *
 * Body params:
 *   sessionId — the session to create the PR for
 */

import { NextResponse } from 'next/server';
import { getSession } from '../../../../lib/session.js';
import { supabase } from '../../../../lib/supabase.js';

export async function POST(request) {
  const user = await getSession();
  if (!user) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });

  const { data: site } = await supabase
    .from('seofix_sites')
    .select('*')
    .eq('user_id', user.id)
    .single();

  if (!site) return NextResponse.json({ error: 'No repository connected.' }, { status: 400 });

  const { sessionId } = await request.json();
  if (!sessionId) return NextResponse.json({ error: 'Missing sessionId.' }, { status: 400 });

  // Load session
  const { data: session } = await supabase
    .from('seofix_sessions')
    .select('*')
    .eq('id', sessionId)
    .eq('user_id', user.id)
    .single();

  if (!session) return NextResponse.json({ error: 'Session not found.' }, { status: 404 });
  if (session.status !== 'open') return NextResponse.json({ error: 'Session is already closed.' }, { status: 400 });

  // Load all committed fixes (exclude skipped)
  const { data: fixes } = await supabase
    .from('seofix_fixes')
    .select('*')
    .eq('session_id', sessionId)
    .eq('status', 'committed')
    .order('created_at', { ascending: true });

  if (!fixes || fixes.length === 0) {
    return NextResponse.json({ error: 'No committed fixes in this session.' }, { status: 400 });
  }

  const { github_owner: owner, github_repo: repo, github_branch: baseBranch } = site;
  const token = user.github_token;
  const apiBase = `https://api.github.com/repos/${owner}/${repo}`;
  const headers = {
    Authorization: `Bearer ${token}`,
    Accept: 'application/vnd.github.v3+json',
    'Content-Type': 'application/json',
  };

  // Build PR title — summarize what was fixed
  const uniqueIssues = [...new Set(fixes.map(f => f.issue_title))];
  const prTitle = uniqueIssues.length === 1
    ? `[SEOFix] ${uniqueIssues[0]}`
    : `[SEOFix] ${fixes.length} SEO fixes — ${session.domain}`;

  // Build PR body — list every fix
  const fixLines = fixes.map(fix =>
    `### ${fix.issue_title}\n- **Page:** [${fix.page_url}](${fix.page_url})\n- **File:** \`${fix.file_path}\`\n- **Fix:** ${fix.description}`
  ).join('\n\n');

  const prBody = `## SEOFix — Automated SEO Fixes

This pull request was generated by [SEOFix](https://seo-fixer.vercel.app) and contains **${fixes.length} fix${fixes.length !== 1 ? 'es' : ''}** for **${session.domain}**.

---

${fixLines}

---

> Please review each change in the **Files changed** tab before merging.
> These fixes were committed to branch \`${session.branch_name}\`.
> Generated by SEOFix on ${new Date().toLocaleDateString()}.
`;

  try {
    const prRes = await fetch(`${apiBase}/pulls`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        title: prTitle,
        body: prBody,
        head: session.branch_name,
        base: baseBranch,
      }),
    });

    if (!prRes.ok) {
      const err = await prRes.json();
      return NextResponse.json({ error: `Could not create PR: ${err.message}` }, { status: 502 });
    }

    const pr = await prRes.json();

    // Update session status to pr_created
    await supabase
      .from('seofix_sessions')
      .update({
        status: 'pr_created',
        pr_url: pr.html_url,
        pr_number: pr.number,
      })
      .eq('id', sessionId);

    return NextResponse.json({
      pr: {
        number: pr.number,
        title: pr.title,
        url: pr.html_url,
        branch: session.branch_name,
        fixCount: fixes.length,
      },
    });

  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
